spec:
  inputs:
    # Develocity server URL
    url:
      default: 'https://scans.gradle.com'
    # Develocity Plugin version
    gradlePluginVersion:
      default: '3.16.2'
    # Develocity Gradle plugin repository URL, defaults in the init script to https://plugins.gradle.org/m2
    gradlePluginRepositoryUrl:
      default: ''
    # Develocity Gradle plugin repository username
    gradlePluginRepositoryUsername:
      default: ''
    # Develocity Gradle plugin repository password, strongly advised to pass a protected and masked variable
    gradlePluginRepositoryPassword:
      default: ''
    # Enforce the url over any defined locally to the project
    enforceUrl:
      default: 'false'
    # Common Custom User Data Gradle Plugin version (see https://github.com/gradle/common-custom-user-data-gradle-plugin/)
    ccudPluginVersion:
      default: '1.13'
    # Allow untrusted server
    allowUntrustedServer:
      default: 'false'

---
.build_scan_links_report:
  artifacts:
    reports:
      annotations: $CI_PROJECT_DIR/build-scan-links.json

.injectDevelocityForGradle: |
  function create_gradle_report_init() {
    local init_script="${CI_PROJECT_DIR}/build-result-capture.init.groovy"
    export BUILD_SCAN_REPORT_PATH="${CI_PROJECT_DIR}/build-scan-links.json"

    cat > $init_script <<'EOF'
      /*
      * Capture information for each executed Gradle build to display in the job attached annotation.
      */
      import org.gradle.util.GradleVersion

      // Only run against root build. Do not run against included builds.
      def isTopLevelBuild = gradle.getParent() == null
      if (isTopLevelBuild) {
        def version = GradleVersion.current().baseVersion

        def atLeastGradle3 = version >= GradleVersion.version("3.0")
        def atLeastGradle6 = version >= GradleVersion.version("6.0")

        if (atLeastGradle6) {
          def useBuildService = version >= GradleVersion.version("6.6")
          settingsEvaluated { settings ->
            settings.pluginManager.withPlugin("com.gradle.enterprise") {
              captureUsingBuildScanPublished(settings.extensions["gradleEnterprise"].buildScan, settings.rootProject)
            }
          }
        } else if (atLeastGradle3) {
          projectsEvaluated { gradle ->
            gradle.rootProject.pluginManager.withPlugin("com.gradle.build-scan") {
              captureUsingBuildScanPublished(gradle.rootProject.extensions["buildScan"], gradle.rootProject)
            }
          }
        }
      }

      def captureUsingBuildScanPublished(buildScanExtension, rootProject) {
        buildScanExtension.with {
          buildScanPublished { buildScan ->
            if (System.getenv("BUILD_SCAN_REPORT_PATH")) {
              def reportFile = new File(System.getenv("BUILD_SCAN_REPORT_PATH"))
              def report
              // This might have been created by a previous Gradle invocation in the same GitLab job
              // Note that we do not handle parallel Gradle scripts invocation, which should be a very edge case in context of a GitLab job
              if (reportFile.exists()) {
                report = new groovy.json.JsonSlurper().parseText(reportFile.text) as Report
              } else {
                report = new Report()
              }
              report.addLink("${buildScan.buildScanUri}")
              def generator = new groovy.json.JsonGenerator.Options()
                .excludeFieldsByName('contentHash', 'originalClassName')
                .build()
              reportFile.text = generator.toJson(report)
            }
          }
        }
      }

      class Report {
        List<Link> build_scans = []

        void addLink(String url) {
          build_scans << new Link(url)
        }
      }

      class Link {
        Map external_link

        Link(String url) {
          external_link = [ 'label': url, 'url': url ]
        }
      }
    EOF
  }
  create_gradle_report_init

  function create_gradle_init() {
    local init_script="${CI_PROJECT_DIR}/init-script.gradle"

    cat > $init_script <<'EOF'
      import org.gradle.util.GradleVersion

      // note that there is no mechanism to share code between the initscript{} block and the main script, so some logic is duplicated

      // conditionally apply the GE / Build Scan plugin to the classpath so it can be applied to the build further down in this script
      initscript {
          def isTopLevelBuild = !gradle.parent
          if (!isTopLevelBuild) {
              return
          }

          def getInputParam = { String name ->
              def envVarName = name.toUpperCase().replace('.', '_').replace('-', '_')
              return System.getProperty(name) ?: System.getenv(envVarName)
          }

          // finish early if injection is disabled
          def gradleInjectionEnabled = getInputParam("develocity.gradle-injection-enabled")
          if (gradleInjectionEnabled == "false") {
              return
          }

          def pluginRepositoryUrl = getInputParam('gradle.plugin-repository.url')
          def pluginRepositoryUsername = getInputParam('gradle.plugin-repository.username')
          def pluginRepositoryPassword = getInputParam('gradle.plugin-repository.password')
          def gePluginVersion = getInputParam('develocity.plugin.version')
          def ccudPluginVersion = getInputParam('develocity.ccud.plugin.version')

          def atLeastGradle5 = GradleVersion.current() >= GradleVersion.version('5.0')
          def atLeastGradle4 = GradleVersion.current() >= GradleVersion.version('4.0')

          if (gePluginVersion || ccudPluginVersion && atLeastGradle4) {
              pluginRepositoryUrl = pluginRepositoryUrl ?: 'https://plugins.gradle.org/m2'
              logger.lifecycle("Gradle Enterprise plugins resolution: $pluginRepositoryUrl")

              repositories {
                  maven {
                      url pluginRepositoryUrl
                      if (pluginRepositoryUsername && pluginRepositoryPassword) {
                          logger.lifecycle("Using credentials for plugin repository")
                          credentials {
                              username(pluginRepositoryUsername)
                              password(pluginRepositoryPassword)
                          }
                          authentication {
                              basic(BasicAuthentication)
                          }
                      }
                  }
              }
          }

          dependencies {
              if (gePluginVersion) {
                  classpath atLeastGradle5 ?
                      "com.gradle:gradle-enterprise-gradle-plugin:$gePluginVersion" :
                      "com.gradle:build-scan-plugin:1.16"
              }

              if (ccudPluginVersion && atLeastGradle4) {
                  classpath "com.gradle:common-custom-user-data-gradle-plugin:$ccudPluginVersion"
              }
          }
      }

      def BUILD_SCAN_PLUGIN_ID = 'com.gradle.build-scan'
      def BUILD_SCAN_PLUGIN_CLASS = 'com.gradle.scan.plugin.BuildScanPlugin'

      def GRADLE_ENTERPRISE_PLUGIN_ID = 'com.gradle.enterprise'
      def GRADLE_ENTERPRISE_PLUGIN_CLASS = 'com.gradle.enterprise.gradleplugin.GradleEnterprisePlugin'
      def GRADLE_ENTERPRISE_EXTENSION_CLASS = 'com.gradle.enterprise.gradleplugin.GradleEnterpriseExtension'
      def CI_AUTO_INJECTION_CUSTOM_VALUE_NAME = 'CI auto injection'
      def CI_AUTO_INJECTION_CUSTOM_VALUE_VALUE = 'GitLab'
      def CCUD_PLUGIN_ID = 'com.gradle.common-custom-user-data-gradle-plugin'
      def CCUD_PLUGIN_CLASS = 'com.gradle.CommonCustomUserDataGradlePlugin'

      def isTopLevelBuild = !gradle.parent
      if (!isTopLevelBuild) {
          return
      }

      def getInputParam = { String name ->
          def envVarName = name.toUpperCase().replace('.', '_').replace('-', '_')
          return System.getProperty(name) ?: System.getenv(envVarName)
      }

      // finish early if injection is disabled
      def gradleInjectionEnabled = getInputParam("develocity.gradle-injection-enabled")
      if (gradleInjectionEnabled == "false") {
          return
      }

      def geUrl = getInputParam('develocity.url')
      def geAllowUntrustedServer = Boolean.parseBoolean(getInputParam('develocity.allow-untrusted-server'))
      def geEnforceUrl = Boolean.parseBoolean(getInputParam('develocity.enforce-url'))
      def gePluginVersion = getInputParam('develocity.plugin.version')
      def ccudPluginVersion = getInputParam('develocity.ccud.plugin.version')

      def atLeastGradle4 = GradleVersion.current() >= GradleVersion.version('4.0')

      // finish early if configuration parameters passed in via system properties are not valid/supported
      if (ccudPluginVersion && isNotAtLeast(ccudPluginVersion, '1.7')) {
          logger.warn("Common Custom User Data Gradle plugin must be at least 1.7. Configured version is $ccudPluginVersion.")
          return
      }

      // register buildScanPublished listener and optionally apply the GE / Build Scan plugin
      if (GradleVersion.current() < GradleVersion.version('6.0')) {
          rootProject {
              buildscript.configurations.getByName("classpath").incoming.afterResolve { ResolvableDependencies incoming ->
                  def resolutionResult = incoming.resolutionResult

                  if (gePluginVersion) {
                      def scanPluginComponent = resolutionResult.allComponents.find {
                          it.moduleVersion.with { group == "com.gradle" && (name == "build-scan-plugin" || name == "gradle-enterprise-gradle-plugin") }
                      }
                      if (!scanPluginComponent) {
                          logger.lifecycle("Applying $BUILD_SCAN_PLUGIN_CLASS via init script")
                          logger.lifecycle("Connection to Gradle Enterprise: $geUrl, allowUntrustedServer: $geAllowUntrustedServer")
                          applyPluginExternally(pluginManager, BUILD_SCAN_PLUGIN_CLASS)
                          buildScan.server = geUrl
                          buildScan.allowUntrustedServer = geAllowUntrustedServer
                          buildScan.publishAlways()
                          if (buildScan.metaClass.respondsTo(buildScan, 'setUploadInBackground', Boolean)) buildScan.uploadInBackground = false  // uploadInBackground not available for build-scan-plugin 1.16
                          buildScan.value CI_AUTO_INJECTION_CUSTOM_VALUE_NAME, CI_AUTO_INJECTION_CUSTOM_VALUE_VALUE
                      }

                      if (geUrl && geEnforceUrl) {
                          pluginManager.withPlugin(BUILD_SCAN_PLUGIN_ID) {
                              afterEvaluate {
                                  logger.lifecycle("Enforcing Gradle Enterprise: $geUrl, allowUntrustedServer: $geAllowUntrustedServer")
                                  buildScan.server = geUrl
                                  buildScan.allowUntrustedServer = geAllowUntrustedServer
                              }
                          }
                      }
                  }

                  if (ccudPluginVersion && atLeastGradle4) {
                      def ccudPluginComponent = resolutionResult.allComponents.find {
                          it.moduleVersion.with { group == "com.gradle" && name == "common-custom-user-data-gradle-plugin" }
                      }
                      if (!ccudPluginComponent) {
                          logger.lifecycle("Applying $CCUD_PLUGIN_CLASS via init script")
                          pluginManager.apply(initscript.classLoader.loadClass(CCUD_PLUGIN_CLASS))
                      }
                  }
              }
          }
      } else {
          gradle.settingsEvaluated { settings ->
              if (gePluginVersion) {
                  if (!settings.pluginManager.hasPlugin(GRADLE_ENTERPRISE_PLUGIN_ID)) {
                      logger.lifecycle("Applying $GRADLE_ENTERPRISE_PLUGIN_CLASS via init script")
                      logger.lifecycle("Connection to Gradle Enterprise: $geUrl, allowUntrustedServer: $geAllowUntrustedServer")
                      applyPluginExternally(settings.pluginManager, GRADLE_ENTERPRISE_PLUGIN_CLASS)
                      extensionsWithPublicType(settings, GRADLE_ENTERPRISE_EXTENSION_CLASS).collect { settings[it.name] }.each { ext ->
                          ext.server = geUrl
                          ext.allowUntrustedServer = geAllowUntrustedServer
                          ext.buildScan.publishAlways()
                          ext.buildScan.uploadInBackground = false
                          ext.buildScan.value CI_AUTO_INJECTION_CUSTOM_VALUE_NAME, CI_AUTO_INJECTION_CUSTOM_VALUE_VALUE
                      }
                  }

                  if (geUrl && geEnforceUrl) {
                      extensionsWithPublicType(settings, GRADLE_ENTERPRISE_EXTENSION_CLASS).collect { settings[it.name] }.each { ext ->
                          logger.lifecycle("Enforcing Gradle Enterprise: $geUrl, allowUntrustedServer: $geAllowUntrustedServer")
                          ext.server = geUrl
                          ext.allowUntrustedServer = geAllowUntrustedServer
                      }
                  }
              }

              if (ccudPluginVersion) {
                  if (!settings.pluginManager.hasPlugin(CCUD_PLUGIN_ID)) {
                      logger.lifecycle("Applying $CCUD_PLUGIN_CLASS via init script")
                      settings.pluginManager.apply(initscript.classLoader.loadClass(CCUD_PLUGIN_CLASS))
                  }
              }
          }
      }

      apply from: "${CI_PROJECT_DIR}/build-result-capture.init.groovy"

      void applyPluginExternally(PluginManager pluginManager, String pluginClassName) {
          def externallyApplied = 'gradle.enterprise.externally-applied'
          def oldValue = System.getProperty(externallyApplied)
          System.setProperty(externallyApplied, 'true')
          try {
              pluginManager.apply(initscript.classLoader.loadClass(pluginClassName))
          } finally {
              if (oldValue == null) {
                  System.clearProperty(externallyApplied)
              } else {
                  System.setProperty(externallyApplied, oldValue)
              }
          }
      }

      static def extensionsWithPublicType(def container, String publicType) {
          container.extensions.extensionsSchema.elements.findAll { it.publicType.concreteClass.name == publicType }
      }

      static boolean isNotAtLeast(String versionUnderTest, String referenceVersion) {
          GradleVersion.version(versionUnderTest) < GradleVersion.version(referenceVersion)
      }
  EOF

    export DEVELOCITY_INIT_SCRIPT_PATH="${init_script}"
  }

  function inject_develocity_for_gradle() {
    export "DEVELOCITY_URL=$[[ inputs.url ]]"
    export "DEVELOCITY_PLUGIN_VERSION=$[[ inputs.gradlePluginVersion ]]"
    export "DEVELOCITY_CCUD_PLUGIN_VERSION=$[[ inputs.ccudPluginVersion ]]"
    export "DEVELOCITY_ALLOW_UNTRUSTED_SERVER=$[[ inputs.allowUntrustedServer ]]"
    export "DEVELOCITY_ENFORCE_URL=$[[ inputs.enforceUrl ]]"
    export "GRADLE_PLUGIN_REPOSITORY_URL=$[[ inputs.gradlePluginRepositoryUrl ]]"
    export "GRADLE_PLUGIN_REPOSITORY_USERNAME=$[[ inputs.gradlePluginRepositoryUsername ]]"
    export "GRADLE_PLUGIN_REPOSITORY_PASSWORD=$[[ inputs.gradlePluginRepositoryPassword ]]"
  }

  create_gradle_init
  inject_develocity_for_gradle
